// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Cellml_1_2.h"

namespace cellml12
{
  // Model
  // 

  const Model::ImportSequence& Model::
  getImport () const
  {
    return this->import_;
  }

  Model::ImportSequence& Model::
  getImport ()
  {
    return this->import_;
  }

  void Model::
  setImport (const ImportSequence& s)
  {
    this->import_ = s;
  }

  const Model::UnitsSequence& Model::
  getUnits () const
  {
    return this->units_;
  }

  Model::UnitsSequence& Model::
  getUnits ()
  {
    return this->units_;
  }

  void Model::
  setUnits (const UnitsSequence& s)
  {
    this->units_ = s;
  }

  const Model::ComponentSequence& Model::
  getComponent () const
  {
    return this->component_;
  }

  Model::ComponentSequence& Model::
  getComponent ()
  {
    return this->component_;
  }

  void Model::
  setComponent (const ComponentSequence& s)
  {
    this->component_ = s;
  }

  const Model::EncapsulationSequence& Model::
  getEncapsulation () const
  {
    return this->encapsulation_;
  }

  Model::EncapsulationSequence& Model::
  getEncapsulation ()
  {
    return this->encapsulation_;
  }

  void Model::
  setEncapsulation (const EncapsulationSequence& s)
  {
    this->encapsulation_ = s;
  }

  const Model::ConnectionSequence& Model::
  getConnection () const
  {
    return this->connection_;
  }

  Model::ConnectionSequence& Model::
  getConnection ()
  {
    return this->connection_;
  }

  void Model::
  setConnection (const ConnectionSequence& s)
  {
    this->connection_ = s;
  }

  const Model::NameType& Model::
  getName () const
  {
    return this->name_.get ();
  }

  Model::NameType& Model::
  getName ()
  {
    return this->name_.get ();
  }

  void Model::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Model::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // Import
  // 

  const Import::UnitsSequence& Import::
  getUnits () const
  {
    return this->units_;
  }

  Import::UnitsSequence& Import::
  getUnits ()
  {
    return this->units_;
  }

  void Import::
  setUnits (const UnitsSequence& s)
  {
    this->units_ = s;
  }

  const Import::ComponentSequence& Import::
  getComponent () const
  {
    return this->component_;
  }

  Import::ComponentSequence& Import::
  getComponent ()
  {
    return this->component_;
  }

  void Import::
  setComponent (const ComponentSequence& s)
  {
    this->component_ = s;
  }

  const Import::HrefType& Import::
  getHref () const
  {
    return this->href_.get ();
  }

  Import::HrefType& Import::
  getHref ()
  {
    return this->href_.get ();
  }

  void Import::
  setHref (const HrefType& x)
  {
    this->href_.set (x);
  }

  void Import::
  setHref (::std::unique_ptr< HrefType > x)
  {
    this->href_.set (std::move (x));
  }


  // Units
  // 

  const Units::UnitSequence& Units::
  getUnit () const
  {
    return this->unit_;
  }

  Units::UnitSequence& Units::
  getUnit ()
  {
    return this->unit_;
  }

  void Units::
  setUnit (const UnitSequence& s)
  {
    this->unit_ = s;
  }

  const Units::NameType& Units::
  getName () const
  {
    return this->name_.get ();
  }

  Units::NameType& Units::
  getName ()
  {
    return this->name_.get ();
  }

  void Units::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Units::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const Units::Base_unitsOptional& Units::
  getBase_units () const
  {
    return this->base_units_;
  }

  Units::Base_unitsOptional& Units::
  getBase_units ()
  {
    return this->base_units_;
  }

  void Units::
  setBase_units (const Base_unitsType& x)
  {
    this->base_units_.set (x);
  }

  void Units::
  setBase_units (const Base_unitsOptional& x)
  {
    this->base_units_ = x;
  }

  void Units::
  setBase_units (::std::unique_ptr< Base_unitsType > x)
  {
    this->base_units_.set (std::move (x));
  }


  // Unit
  // 

  const Unit::UnitsType& Unit::
  getUnits () const
  {
    return this->units_.get ();
  }

  Unit::UnitsType& Unit::
  getUnits ()
  {
    return this->units_.get ();
  }

  void Unit::
  setUnits (const UnitsType& x)
  {
    this->units_.set (x);
  }

  void Unit::
  setUnits (::std::unique_ptr< UnitsType > x)
  {
    this->units_.set (std::move (x));
  }

  const Unit::MultiplierOptional& Unit::
  getMultiplier () const
  {
    return this->multiplier_;
  }

  Unit::MultiplierOptional& Unit::
  getMultiplier ()
  {
    return this->multiplier_;
  }

  void Unit::
  setMultiplier (const MultiplierType& x)
  {
    this->multiplier_.set (x);
  }

  void Unit::
  setMultiplier (const MultiplierOptional& x)
  {
    this->multiplier_ = x;
  }

  const Unit::PrefixOptional& Unit::
  getPrefix () const
  {
    return this->prefix_;
  }

  Unit::PrefixOptional& Unit::
  getPrefix ()
  {
    return this->prefix_;
  }

  void Unit::
  setPrefix (const PrefixType& x)
  {
    this->prefix_.set (x);
  }

  void Unit::
  setPrefix (const PrefixOptional& x)
  {
    this->prefix_ = x;
  }

  void Unit::
  setPrefix (::std::unique_ptr< PrefixType > x)
  {
    this->prefix_.set (std::move (x));
  }

  const Unit::OffsetOptional& Unit::
  getOffset () const
  {
    return this->offset_;
  }

  Unit::OffsetOptional& Unit::
  getOffset ()
  {
    return this->offset_;
  }

  void Unit::
  setOffset (const OffsetType& x)
  {
    this->offset_.set (x);
  }

  void Unit::
  setOffset (const OffsetOptional& x)
  {
    this->offset_ = x;
  }

  const Unit::ExponentOptional& Unit::
  getExponent () const
  {
    return this->exponent_;
  }

  Unit::ExponentOptional& Unit::
  getExponent ()
  {
    return this->exponent_;
  }

  void Unit::
  setExponent (const ExponentType& x)
  {
    this->exponent_.set (x);
  }

  void Unit::
  setExponent (const ExponentOptional& x)
  {
    this->exponent_ = x;
  }


  // Component
  // 

  const Component::UnitsSequence& Component::
  getUnits () const
  {
    return this->units_;
  }

  Component::UnitsSequence& Component::
  getUnits ()
  {
    return this->units_;
  }

  void Component::
  setUnits (const UnitsSequence& s)
  {
    this->units_ = s;
  }

  const Component::VariableSequence& Component::
  getVariable () const
  {
    return this->variable_;
  }

  Component::VariableSequence& Component::
  getVariable ()
  {
    return this->variable_;
  }

  void Component::
  setVariable (const VariableSequence& s)
  {
    this->variable_ = s;
  }

  const Component::MathSequence& Component::
  getMath () const
  {
    return this->math_;
  }

  Component::MathSequence& Component::
  getMath ()
  {
    return this->math_;
  }

  void Component::
  setMath (const MathSequence& s)
  {
    this->math_ = s;
  }

  const Component::NameType& Component::
  getName () const
  {
    return this->name_.get ();
  }

  Component::NameType& Component::
  getName ()
  {
    return this->name_.get ();
  }

  void Component::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Component::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // Encapsulation
  // 

  const Encapsulation::Component_refSequence& Encapsulation::
  getComponent_ref () const
  {
    return this->component_ref_;
  }

  Encapsulation::Component_refSequence& Encapsulation::
  getComponent_ref ()
  {
    return this->component_ref_;
  }

  void Encapsulation::
  setComponent_ref (const Component_refSequence& s)
  {
    this->component_ref_ = s;
  }


  // ToplevelComponentRef
  // 

  const ToplevelComponentRef::Component_refSequence& ToplevelComponentRef::
  getComponent_ref () const
  {
    return this->component_ref_;
  }

  ToplevelComponentRef::Component_refSequence& ToplevelComponentRef::
  getComponent_ref ()
  {
    return this->component_ref_;
  }

  void ToplevelComponentRef::
  setComponent_ref (const Component_refSequence& s)
  {
    this->component_ref_ = s;
  }

  const ToplevelComponentRef::ComponentType& ToplevelComponentRef::
  getComponent () const
  {
    return this->component_.get ();
  }

  ToplevelComponentRef::ComponentType& ToplevelComponentRef::
  getComponent ()
  {
    return this->component_.get ();
  }

  void ToplevelComponentRef::
  setComponent (const ComponentType& x)
  {
    this->component_.set (x);
  }

  void ToplevelComponentRef::
  setComponent (::std::unique_ptr< ComponentType > x)
  {
    this->component_.set (std::move (x));
  }


  // ComponentRef
  // 

  const ComponentRef::Component_refSequence& ComponentRef::
  getComponent_ref () const
  {
    return this->component_ref_;
  }

  ComponentRef::Component_refSequence& ComponentRef::
  getComponent_ref ()
  {
    return this->component_ref_;
  }

  void ComponentRef::
  setComponent_ref (const Component_refSequence& s)
  {
    this->component_ref_ = s;
  }

  const ComponentRef::ComponentType& ComponentRef::
  getComponent () const
  {
    return this->component_.get ();
  }

  ComponentRef::ComponentType& ComponentRef::
  getComponent ()
  {
    return this->component_.get ();
  }

  void ComponentRef::
  setComponent (const ComponentType& x)
  {
    this->component_.set (x);
  }

  void ComponentRef::
  setComponent (::std::unique_ptr< ComponentType > x)
  {
    this->component_.set (std::move (x));
  }


  // Connection
  // 

  const Connection::Map_variablesSequence& Connection::
  getMap_variables () const
  {
    return this->map_variables_;
  }

  Connection::Map_variablesSequence& Connection::
  getMap_variables ()
  {
    return this->map_variables_;
  }

  void Connection::
  setMap_variables (const Map_variablesSequence& s)
  {
    this->map_variables_ = s;
  }

  const Connection::Component_1Type& Connection::
  getComponent_1 () const
  {
    return this->component_1_.get ();
  }

  Connection::Component_1Type& Connection::
  getComponent_1 ()
  {
    return this->component_1_.get ();
  }

  void Connection::
  setComponent_1 (const Component_1Type& x)
  {
    this->component_1_.set (x);
  }

  void Connection::
  setComponent_1 (::std::unique_ptr< Component_1Type > x)
  {
    this->component_1_.set (std::move (x));
  }

  const Connection::Component_2Type& Connection::
  getComponent_2 () const
  {
    return this->component_2_.get ();
  }

  Connection::Component_2Type& Connection::
  getComponent_2 ()
  {
    return this->component_2_.get ();
  }

  void Connection::
  setComponent_2 (const Component_2Type& x)
  {
    this->component_2_.set (x);
  }

  void Connection::
  setComponent_2 (::std::unique_ptr< Component_2Type > x)
  {
    this->component_2_.set (std::move (x));
  }


  // ImportedUnits
  // 

  const ImportedUnits::NameType& ImportedUnits::
  getName () const
  {
    return this->name_.get ();
  }

  ImportedUnits::NameType& ImportedUnits::
  getName ()
  {
    return this->name_.get ();
  }

  void ImportedUnits::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ImportedUnits::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const ImportedUnits::Units_refType& ImportedUnits::
  getUnits_ref () const
  {
    return this->units_ref_.get ();
  }

  ImportedUnits::Units_refType& ImportedUnits::
  getUnits_ref ()
  {
    return this->units_ref_.get ();
  }

  void ImportedUnits::
  setUnits_ref (const Units_refType& x)
  {
    this->units_ref_.set (x);
  }

  void ImportedUnits::
  setUnits_ref (::std::unique_ptr< Units_refType > x)
  {
    this->units_ref_.set (std::move (x));
  }


  // ImportedComponent
  // 

  const ImportedComponent::NameType& ImportedComponent::
  getName () const
  {
    return this->name_.get ();
  }

  ImportedComponent::NameType& ImportedComponent::
  getName ()
  {
    return this->name_.get ();
  }

  void ImportedComponent::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ImportedComponent::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const ImportedComponent::Component_refType& ImportedComponent::
  getComponent_ref () const
  {
    return this->component_ref_.get ();
  }

  ImportedComponent::Component_refType& ImportedComponent::
  getComponent_ref ()
  {
    return this->component_ref_.get ();
  }

  void ImportedComponent::
  setComponent_ref (const Component_refType& x)
  {
    this->component_ref_.set (x);
  }

  void ImportedComponent::
  setComponent_ref (::std::unique_ptr< Component_refType > x)
  {
    this->component_ref_.set (std::move (x));
  }


  // Variable
  // 

  const Variable::NameType& Variable::
  getName () const
  {
    return this->name_.get ();
  }

  Variable::NameType& Variable::
  getName ()
  {
    return this->name_.get ();
  }

  void Variable::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Variable::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const Variable::UnitsType& Variable::
  getUnits () const
  {
    return this->units_.get ();
  }

  Variable::UnitsType& Variable::
  getUnits ()
  {
    return this->units_.get ();
  }

  void Variable::
  setUnits (const UnitsType& x)
  {
    this->units_.set (x);
  }

  void Variable::
  setUnits (::std::unique_ptr< UnitsType > x)
  {
    this->units_.set (std::move (x));
  }

  const Variable::Public_interfaceOptional& Variable::
  getPublic_interface () const
  {
    return this->public_interface_;
  }

  Variable::Public_interfaceOptional& Variable::
  getPublic_interface ()
  {
    return this->public_interface_;
  }

  void Variable::
  setPublic_interface (const Public_interfaceType& x)
  {
    this->public_interface_.set (x);
  }

  void Variable::
  setPublic_interface (const Public_interfaceOptional& x)
  {
    this->public_interface_ = x;
  }

  void Variable::
  setPublic_interface (::std::unique_ptr< Public_interfaceType > x)
  {
    this->public_interface_.set (std::move (x));
  }

  const Variable::Private_interfaceOptional& Variable::
  getPrivate_interface () const
  {
    return this->private_interface_;
  }

  Variable::Private_interfaceOptional& Variable::
  getPrivate_interface ()
  {
    return this->private_interface_;
  }

  void Variable::
  setPrivate_interface (const Private_interfaceType& x)
  {
    this->private_interface_.set (x);
  }

  void Variable::
  setPrivate_interface (const Private_interfaceOptional& x)
  {
    this->private_interface_ = x;
  }

  void Variable::
  setPrivate_interface (::std::unique_ptr< Private_interfaceType > x)
  {
    this->private_interface_.set (std::move (x));
  }

  const Variable::TypeType& Variable::
  getType () const
  {
    return this->type_.get ();
  }

  Variable::TypeType& Variable::
  getType ()
  {
    return this->type_.get ();
  }

  void Variable::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void Variable::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->type_.set (std::move (x));
  }


  // MapVariables
  // 

  const MapVariables::Variable_1Type& MapVariables::
  getVariable_1 () const
  {
    return this->variable_1_.get ();
  }

  MapVariables::Variable_1Type& MapVariables::
  getVariable_1 ()
  {
    return this->variable_1_.get ();
  }

  void MapVariables::
  setVariable_1 (const Variable_1Type& x)
  {
    this->variable_1_.set (x);
  }

  void MapVariables::
  setVariable_1 (::std::unique_ptr< Variable_1Type > x)
  {
    this->variable_1_.set (std::move (x));
  }

  const MapVariables::Variable_2Type& MapVariables::
  getVariable_2 () const
  {
    return this->variable_2_.get ();
  }

  MapVariables::Variable_2Type& MapVariables::
  getVariable_2 ()
  {
    return this->variable_2_.get ();
  }

  void MapVariables::
  setVariable_2 (const Variable_2Type& x)
  {
    this->variable_2_.set (x);
  }

  void MapVariables::
  setVariable_2 (::std::unique_ptr< Variable_2Type > x)
  {
    this->variable_2_.set (std::move (x));
  }


  // CellMLIdentifier
  // 


  // UnitPrefix
  //

  UnitPrefix::
  UnitPrefix (const wchar_t* s)
  : ::xml_schema::String (s)
  {
  }

  UnitPrefix::
  UnitPrefix (const ::std::wstring& s)
  : ::xml_schema::String (s)
  {
  }

  UnitPrefix::
  UnitPrefix (const UnitPrefix& o,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (o, f, c)
  {
  }

  // Yesno
  // 

  Yesno::
  Yesno (Value v)
  : ::xml_schema::String (_xsd_Yesno_literals_[v])
  {
  }

  Yesno::
  Yesno (const wchar_t* v)
  : ::xml_schema::String (v)
  {
  }

  Yesno::
  Yesno (const ::std::wstring& v)
  : ::xml_schema::String (v)
  {
  }

  Yesno::
  Yesno (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Yesno::
  Yesno (const Yesno& v,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Yesno& Yesno::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Yesno_literals_[v]);

    return *this;
  }


  // UnitPrefix_member
  // 

  UnitPrefix_member::
  UnitPrefix_member (Value v)
  : ::xml_schema::String (_xsd_UnitPrefix_member_literals_[v])
  {
  }

  UnitPrefix_member::
  UnitPrefix_member (const wchar_t* v)
  : ::xml_schema::String (v)
  {
  }

  UnitPrefix_member::
  UnitPrefix_member (const ::std::wstring& v)
  : ::xml_schema::String (v)
  {
  }

  UnitPrefix_member::
  UnitPrefix_member (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  UnitPrefix_member::
  UnitPrefix_member (const UnitPrefix_member& v,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  UnitPrefix_member& UnitPrefix_member::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_UnitPrefix_member_literals_[v]);

    return *this;
  }


  // UnitPrefix_member1
  // 
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace cellml12
{
  // Model
  //

  Model::
  Model (const NameType& name)
  : ::xml_schema::Type (),
    import_ (this),
    units_ (this),
    component_ (this),
    encapsulation_ (this),
    connection_ (this),
    name_ (name, this)
  {
  }

  Model::
  Model (const Model& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    import_ (x.import_, f, this),
    units_ (x.units_, f, this),
    component_ (x.component_, f, this),
    encapsulation_ (x.encapsulation_, f, this),
    connection_ (x.connection_, f, this),
    name_ (x.name_, f, this)
  {
  }

  Model::
  Model (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    import_ (this),
    units_ (this),
    component_ (this),
    encapsulation_ (this),
    connection_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Model::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // import
      //
      if (n.name () == L"import" && n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< ImportType > r (
          ImportTraits::create (i, f, this));

        this->import_.push_back (::std::move (r));
        continue;
      }

      // units
      //
      if (n.name () == L"units" && n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< UnitsType > r (
          UnitsTraits::create (i, f, this));

        this->units_.push_back (::std::move (r));
        continue;
      }

      // component
      //
      if (n.name () == L"component" && n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< ComponentType > r (
          ComponentTraits::create (i, f, this));

        this->component_.push_back (::std::move (r));
        continue;
      }

      // encapsulation
      //
      if (n.name () == L"encapsulation" && n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< EncapsulationType > r (
          EncapsulationTraits::create (i, f, this));

        this->encapsulation_.push_back (::std::move (r));
        continue;
      }

      // connection
      //
      if (n.name () == L"connection" && n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< ConnectionType > r (
          ConnectionTraits::create (i, f, this));

        this->connection_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      if (n.name () == L"name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"name",
        L"");
    }
  }

  Model* Model::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Model (*this, f, c);
  }

  Model& Model::
  operator= (const Model& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->import_ = x.import_;
      this->units_ = x.units_;
      this->component_ = x.component_;
      this->encapsulation_ = x.encapsulation_;
      this->connection_ = x.connection_;
      this->name_ = x.name_;
    }

    return *this;
  }

  Model::
  ~Model ()
  {
  }

  // Import
  //

  Import::
  Import (const HrefType& href)
  : ::xml_schema::Type (),
    units_ (this),
    component_ (this),
    href_ (href, this)
  {
  }

  Import::
  Import (const Import& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    units_ (x.units_, f, this),
    component_ (x.component_, f, this),
    href_ (x.href_, f, this)
  {
  }

  Import::
  Import (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    units_ (this),
    component_ (this),
    href_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Import::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // units
      //
      if (n.name () == L"units" && n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< UnitsType > r (
          UnitsTraits::create (i, f, this));

        this->units_.push_back (::std::move (r));
        continue;
      }

      // component
      //
      if (n.name () == L"component" && n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< ComponentType > r (
          ComponentTraits::create (i, f, this));

        this->component_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      if (n.name () == L"href" && n.namespace_ ().empty ())
      {
        this->href_.set (HrefTraits::create (i, f, this));
        continue;
      }
    }

    if (!href_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"href",
        L"");
    }
  }

  Import* Import::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Import (*this, f, c);
  }

  Import& Import::
  operator= (const Import& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->units_ = x.units_;
      this->component_ = x.component_;
      this->href_ = x.href_;
    }

    return *this;
  }

  Import::
  ~Import ()
  {
  }

  // Units
  //

  Units::
  Units (const NameType& name)
  : ::xml_schema::Type (),
    unit_ (this),
    name_ (name, this),
    base_units_ (this)
  {
  }

  Units::
  Units (const Units& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    unit_ (x.unit_, f, this),
    name_ (x.name_, f, this),
    base_units_ (x.base_units_, f, this)
  {
  }

  Units::
  Units (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    unit_ (this),
    name_ (this),
    base_units_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Units::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // unit
      //
      if (n.name () == L"unit" && n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< UnitType > r (
          UnitTraits::create (i, f, this));

        this->unit_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      if (n.name () == L"name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == L"base_units" && n.namespace_ ().empty ())
      {
        this->base_units_.set (Base_unitsTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"name",
        L"");
    }
  }

  Units* Units::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Units (*this, f, c);
  }

  Units& Units::
  operator= (const Units& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->unit_ = x.unit_;
      this->name_ = x.name_;
      this->base_units_ = x.base_units_;
    }

    return *this;
  }

  Units::
  ~Units ()
  {
  }

  // Unit
  //

  Unit::
  Unit (const UnitsType& units)
  : ::xml_schema::Type (),
    units_ (units, this),
    multiplier_ (this),
    prefix_ (this),
    offset_ (this),
    exponent_ (this)
  {
  }

  Unit::
  Unit (const Unit& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    units_ (x.units_, f, this),
    multiplier_ (x.multiplier_, f, this),
    prefix_ (x.prefix_, f, this),
    offset_ (x.offset_, f, this),
    exponent_ (x.exponent_, f, this)
  {
  }

  Unit::
  Unit (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    units_ (this),
    multiplier_ (this),
    prefix_ (this),
    offset_ (this),
    exponent_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Unit::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      if (n.name () == L"units" && n.namespace_ ().empty ())
      {
        this->units_.set (UnitsTraits::create (i, f, this));
        continue;
      }

      if (n.name () == L"multiplier" && n.namespace_ ().empty ())
      {
        this->multiplier_.set (MultiplierTraits::create (i, f, this));
        continue;
      }

      if (n.name () == L"prefix" && n.namespace_ ().empty ())
      {
        this->prefix_.set (PrefixTraits::create (i, f, this));
        continue;
      }

      if (n.name () == L"offset" && n.namespace_ ().empty ())
      {
        this->offset_.set (OffsetTraits::create (i, f, this));
        continue;
      }

      if (n.name () == L"exponent" && n.namespace_ ().empty ())
      {
        this->exponent_.set (ExponentTraits::create (i, f, this));
        continue;
      }
    }

    if (!units_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"units",
        L"");
    }
  }

  Unit* Unit::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Unit (*this, f, c);
  }

  Unit& Unit::
  operator= (const Unit& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->units_ = x.units_;
      this->multiplier_ = x.multiplier_;
      this->prefix_ = x.prefix_;
      this->offset_ = x.offset_;
      this->exponent_ = x.exponent_;
    }

    return *this;
  }

  Unit::
  ~Unit ()
  {
  }

  // Component
  //

  Component::
  Component (const NameType& name)
  : ::xml_schema::Type (),
    units_ (this),
    variable_ (this),
    math_ (this),
    name_ (name, this)
  {
  }

  Component::
  Component (const Component& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    units_ (x.units_, f, this),
    variable_ (x.variable_, f, this),
    math_ (x.math_, f, this),
    name_ (x.name_, f, this)
  {
  }

  Component::
  Component (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    units_ (this),
    variable_ (this),
    math_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Component::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // units
      //
      if (n.name () == L"units" && n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< UnitsType > r (
          UnitsTraits::create (i, f, this));

        this->units_.push_back (::std::move (r));
        continue;
      }

      // variable
      //
      if (n.name () == L"variable" && n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< VariableType > r (
          VariableTraits::create (i, f, this));

        this->variable_.push_back (::std::move (r));
        continue;
      }

      // math
      //
      if (n.name () == L"math" && n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< MathType > r (
          MathTraits::create (i, f, this));

        this->math_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      if (n.name () == L"name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"name",
        L"");
    }
  }

  Component* Component::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Component (*this, f, c);
  }

  Component& Component::
  operator= (const Component& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->units_ = x.units_;
      this->variable_ = x.variable_;
      this->math_ = x.math_;
      this->name_ = x.name_;
    }

    return *this;
  }

  Component::
  ~Component ()
  {
  }

  // Encapsulation
  //

  Encapsulation::
  Encapsulation ()
  : ::xml_schema::Type (),
    component_ref_ (this)
  {
  }

  Encapsulation::
  Encapsulation (const Encapsulation& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    component_ref_ (x.component_ref_, f, this)
  {
  }

  Encapsulation::
  Encapsulation (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    component_ref_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Encapsulation::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // component_ref
      //
      if (n.name () == L"component_ref" && n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< Component_refType > r (
          Component_refTraits::create (i, f, this));

        this->component_ref_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Encapsulation* Encapsulation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Encapsulation (*this, f, c);
  }

  Encapsulation& Encapsulation::
  operator= (const Encapsulation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->component_ref_ = x.component_ref_;
    }

    return *this;
  }

  Encapsulation::
  ~Encapsulation ()
  {
  }

  // ToplevelComponentRef
  //

  ToplevelComponentRef::
  ToplevelComponentRef (const ComponentType& component)
  : ::xml_schema::Type (),
    component_ref_ (this),
    component_ (component, this)
  {
  }

  ToplevelComponentRef::
  ToplevelComponentRef (const ToplevelComponentRef& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    component_ref_ (x.component_ref_, f, this),
    component_ (x.component_, f, this)
  {
  }

  ToplevelComponentRef::
  ToplevelComponentRef (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    component_ref_ (this),
    component_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ToplevelComponentRef::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // component_ref
      //
      if (n.name () == L"component_ref" && n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< Component_refType > r (
          Component_refTraits::create (i, f, this));

        this->component_ref_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      if (n.name () == L"component" && n.namespace_ ().empty ())
      {
        this->component_.set (ComponentTraits::create (i, f, this));
        continue;
      }
    }

    if (!component_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"component",
        L"");
    }
  }

  ToplevelComponentRef* ToplevelComponentRef::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ToplevelComponentRef (*this, f, c);
  }

  ToplevelComponentRef& ToplevelComponentRef::
  operator= (const ToplevelComponentRef& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->component_ref_ = x.component_ref_;
      this->component_ = x.component_;
    }

    return *this;
  }

  ToplevelComponentRef::
  ~ToplevelComponentRef ()
  {
  }

  // ComponentRef
  //

  ComponentRef::
  ComponentRef (const ComponentType& component)
  : ::xml_schema::Type (),
    component_ref_ (this),
    component_ (component, this)
  {
  }

  ComponentRef::
  ComponentRef (const ComponentRef& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    component_ref_ (x.component_ref_, f, this),
    component_ (x.component_, f, this)
  {
  }

  ComponentRef::
  ComponentRef (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    component_ref_ (this),
    component_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ComponentRef::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // component_ref
      //
      if (n.name () == L"component_ref" && n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< Component_refType > r (
          Component_refTraits::create (i, f, this));

        this->component_ref_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      if (n.name () == L"component" && n.namespace_ ().empty ())
      {
        this->component_.set (ComponentTraits::create (i, f, this));
        continue;
      }
    }

    if (!component_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"component",
        L"");
    }
  }

  ComponentRef* ComponentRef::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ComponentRef (*this, f, c);
  }

  ComponentRef& ComponentRef::
  operator= (const ComponentRef& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->component_ref_ = x.component_ref_;
      this->component_ = x.component_;
    }

    return *this;
  }

  ComponentRef::
  ~ComponentRef ()
  {
  }

  // Connection
  //

  Connection::
  Connection (const Component_1Type& component_1,
              const Component_2Type& component_2)
  : ::xml_schema::Type (),
    map_variables_ (this),
    component_1_ (component_1, this),
    component_2_ (component_2, this)
  {
  }

  Connection::
  Connection (const Connection& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    map_variables_ (x.map_variables_, f, this),
    component_1_ (x.component_1_, f, this),
    component_2_ (x.component_2_, f, this)
  {
  }

  Connection::
  Connection (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    map_variables_ (this),
    component_1_ (this),
    component_2_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Connection::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      // map_variables
      //
      if (n.name () == L"map_variables" && n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
      {
        ::std::unique_ptr< Map_variablesType > r (
          Map_variablesTraits::create (i, f, this));

        this->map_variables_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      if (n.name () == L"component_1" && n.namespace_ ().empty ())
      {
        this->component_1_.set (Component_1Traits::create (i, f, this));
        continue;
      }

      if (n.name () == L"component_2" && n.namespace_ ().empty ())
      {
        this->component_2_.set (Component_2Traits::create (i, f, this));
        continue;
      }
    }

    if (!component_1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"component_1",
        L"");
    }

    if (!component_2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"component_2",
        L"");
    }
  }

  Connection* Connection::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Connection (*this, f, c);
  }

  Connection& Connection::
  operator= (const Connection& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->map_variables_ = x.map_variables_;
      this->component_1_ = x.component_1_;
      this->component_2_ = x.component_2_;
    }

    return *this;
  }

  Connection::
  ~Connection ()
  {
  }

  // ImportedUnits
  //

  ImportedUnits::
  ImportedUnits (const NameType& name,
                 const Units_refType& units_ref)
  : ::xml_schema::Type (),
    name_ (name, this),
    units_ref_ (units_ref, this)
  {
  }

  ImportedUnits::
  ImportedUnits (const ImportedUnits& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    units_ref_ (x.units_ref_, f, this)
  {
  }

  ImportedUnits::
  ImportedUnits (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    units_ref_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ImportedUnits::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      if (n.name () == L"name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == L"units_ref" && n.namespace_ ().empty ())
      {
        this->units_ref_.set (Units_refTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"name",
        L"");
    }

    if (!units_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"units_ref",
        L"");
    }
  }

  ImportedUnits* ImportedUnits::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImportedUnits (*this, f, c);
  }

  ImportedUnits& ImportedUnits::
  operator= (const ImportedUnits& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->units_ref_ = x.units_ref_;
    }

    return *this;
  }

  ImportedUnits::
  ~ImportedUnits ()
  {
  }

  // ImportedComponent
  //

  ImportedComponent::
  ImportedComponent (const NameType& name,
                     const Component_refType& component_ref)
  : ::xml_schema::Type (),
    name_ (name, this),
    component_ref_ (component_ref, this)
  {
  }

  ImportedComponent::
  ImportedComponent (const ImportedComponent& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    component_ref_ (x.component_ref_, f, this)
  {
  }

  ImportedComponent::
  ImportedComponent (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    component_ref_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ImportedComponent::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      if (n.name () == L"name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == L"component_ref" && n.namespace_ ().empty ())
      {
        this->component_ref_.set (Component_refTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"name",
        L"");
    }

    if (!component_ref_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"component_ref",
        L"");
    }
  }

  ImportedComponent* ImportedComponent::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImportedComponent (*this, f, c);
  }

  ImportedComponent& ImportedComponent::
  operator= (const ImportedComponent& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->component_ref_ = x.component_ref_;
    }

    return *this;
  }

  ImportedComponent::
  ~ImportedComponent ()
  {
  }

  // Variable
  //

  Variable::
  Variable (const NameType& name,
            const UnitsType& units,
            const TypeType& type)
  : ::xml_schema::Type (),
    name_ (name, this),
    units_ (units, this),
    public_interface_ (this),
    private_interface_ (this),
    type_ (type, this)
  {
  }

  Variable::
  Variable (const Variable& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    units_ (x.units_, f, this),
    public_interface_ (x.public_interface_, f, this),
    private_interface_ (x.private_interface_, f, this),
    type_ (x.type_, f, this)
  {
  }

  Variable::
  Variable (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    units_ (this),
    public_interface_ (this),
    private_interface_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Variable::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      if (n.name () == L"name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == L"units" && n.namespace_ ().empty ())
      {
        this->units_.set (UnitsTraits::create (i, f, this));
        continue;
      }

      if (n.name () == L"public_interface" && n.namespace_ ().empty ())
      {
        this->public_interface_.set (Public_interfaceTraits::create (i, f, this));
        continue;
      }

      if (n.name () == L"private_interface" && n.namespace_ ().empty ())
      {
        this->private_interface_.set (Private_interfaceTraits::create (i, f, this));
        continue;
      }

      if (n.name () == L"type" && n.namespace_ ().empty ())
      {
        this->type_.set (TypeTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"name",
        L"");
    }

    if (!units_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"units",
        L"");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"type",
        L"");
    }
  }

  Variable* Variable::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Variable (*this, f, c);
  }

  Variable& Variable::
  operator= (const Variable& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->units_ = x.units_;
      this->public_interface_ = x.public_interface_;
      this->private_interface_ = x.private_interface_;
      this->type_ = x.type_;
    }

    return *this;
  }

  Variable::
  ~Variable ()
  {
  }

  // MapVariables
  //

  MapVariables::
  MapVariables (const Variable_1Type& variable_1,
                const Variable_2Type& variable_2)
  : ::xml_schema::Type (),
    variable_1_ (variable_1, this),
    variable_2_ (variable_2, this)
  {
  }

  MapVariables::
  MapVariables (const MapVariables& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    variable_1_ (x.variable_1_, f, this),
    variable_2_ (x.variable_2_, f, this)
  {
  }

  MapVariables::
  MapVariables (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    variable_1_ (this),
    variable_2_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void MapVariables::
  parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (i));

      if (n.name () == L"variable_1" && n.namespace_ ().empty ())
      {
        this->variable_1_.set (Variable_1Traits::create (i, f, this));
        continue;
      }

      if (n.name () == L"variable_2" && n.namespace_ ().empty ())
      {
        this->variable_2_.set (Variable_2Traits::create (i, f, this));
        continue;
      }
    }

    if (!variable_1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"variable_1",
        L"");
    }

    if (!variable_2_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
        L"variable_2",
        L"");
    }
  }

  MapVariables* MapVariables::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MapVariables (*this, f, c);
  }

  MapVariables& MapVariables::
  operator= (const MapVariables& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->variable_1_ = x.variable_1_;
      this->variable_2_ = x.variable_2_;
    }

    return *this;
  }

  MapVariables::
  ~MapVariables ()
  {
  }

  // CellMLIdentifier
  //

  CellMLIdentifier::
  CellMLIdentifier ()
  : ::xml_schema::String ()
  {
  }

  CellMLIdentifier::
  CellMLIdentifier (const wchar_t* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  CellMLIdentifier::
  CellMLIdentifier (const ::std::wstring& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  CellMLIdentifier::
  CellMLIdentifier (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  CellMLIdentifier::
  CellMLIdentifier (const CellMLIdentifier& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  CellMLIdentifier::
  CellMLIdentifier (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  CellMLIdentifier::
  CellMLIdentifier (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  CellMLIdentifier::
  CellMLIdentifier (const ::std::wstring& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  CellMLIdentifier* CellMLIdentifier::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CellMLIdentifier (*this, f, c);
  }

  CellMLIdentifier::
  ~CellMLIdentifier ()
  {
  }

  // UnitPrefix
  //

  UnitPrefix::
  UnitPrefix (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  UnitPrefix::
  UnitPrefix (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  UnitPrefix::
  UnitPrefix (const ::std::wstring& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  UnitPrefix* UnitPrefix::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UnitPrefix (*this, f, c);
  }

  // Yesno
  //

  Yesno::
  Yesno (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Yesno_convert ();
  }

  Yesno::
  Yesno (const ::xercesc::DOMAttr& a,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Yesno_convert ();
  }

  Yesno::
  Yesno (const ::std::wstring& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Yesno_convert ();
  }

  Yesno* Yesno::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Yesno (*this, f, c);
  }

  Yesno::Value Yesno::
  _xsd_Yesno_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_Yesno_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Yesno_indexes_,
                      _xsd_Yesno_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_Yesno_indexes_ + 2 || _xsd_Yesno_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
    }

    return *i;
  }

  const wchar_t* const Yesno::
  _xsd_Yesno_literals_[2] =
  {
    L"yes",
    L"no"
  };

  const Yesno::Value Yesno::
  _xsd_Yesno_indexes_[2] =
  {
    ::cellml12::Yesno::no,
    ::cellml12::Yesno::yes
  };

  // UnitPrefix_member
  //

  UnitPrefix_member::
  UnitPrefix_member (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_UnitPrefix_member_convert ();
  }

  UnitPrefix_member::
  UnitPrefix_member (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_UnitPrefix_member_convert ();
  }

  UnitPrefix_member::
  UnitPrefix_member (const ::std::wstring& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_UnitPrefix_member_convert ();
  }

  UnitPrefix_member* UnitPrefix_member::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UnitPrefix_member (*this, f, c);
  }

  UnitPrefix_member::Value UnitPrefix_member::
  _xsd_UnitPrefix_member_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< wchar_t > c (_xsd_UnitPrefix_member_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_UnitPrefix_member_indexes_,
                      _xsd_UnitPrefix_member_indexes_ + 20,
                      *this,
                      c));

    if (i == _xsd_UnitPrefix_member_indexes_ + 20 || _xsd_UnitPrefix_member_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < wchar_t > (*this);
    }

    return *i;
  }

  const wchar_t* const UnitPrefix_member::
  _xsd_UnitPrefix_member_literals_[20] =
  {
    L"yotta",
    L"zetta",
    L"exa",
    L"peta",
    L"tera",
    L"giga",
    L"mega",
    L"kilo",
    L"hecto",
    L"deka",
    L"deci",
    L"centi",
    L"milli",
    L"micro",
    L"nano",
    L"pico",
    L"femto",
    L"atto",
    L"zepto",
    L"yocto"
  };

  const UnitPrefix_member::Value UnitPrefix_member::
  _xsd_UnitPrefix_member_indexes_[20] =
  {
    ::cellml12::UnitPrefix_member::atto,
    ::cellml12::UnitPrefix_member::centi,
    ::cellml12::UnitPrefix_member::deci,
    ::cellml12::UnitPrefix_member::deka,
    ::cellml12::UnitPrefix_member::exa,
    ::cellml12::UnitPrefix_member::femto,
    ::cellml12::UnitPrefix_member::giga,
    ::cellml12::UnitPrefix_member::hecto,
    ::cellml12::UnitPrefix_member::kilo,
    ::cellml12::UnitPrefix_member::mega,
    ::cellml12::UnitPrefix_member::micro,
    ::cellml12::UnitPrefix_member::milli,
    ::cellml12::UnitPrefix_member::nano,
    ::cellml12::UnitPrefix_member::peta,
    ::cellml12::UnitPrefix_member::pico,
    ::cellml12::UnitPrefix_member::tera,
    ::cellml12::UnitPrefix_member::yocto,
    ::cellml12::UnitPrefix_member::yotta,
    ::cellml12::UnitPrefix_member::zepto,
    ::cellml12::UnitPrefix_member::zetta
  };

  // UnitPrefix_member1
  //

  UnitPrefix_member1::
  UnitPrefix_member1 (const ::xml_schema::Integer& _xsd_Integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, wchar_t, ::xml_schema::SimpleType > (_xsd_Integer_base)
  {
  }

  UnitPrefix_member1::
  UnitPrefix_member1 (const UnitPrefix_member1& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, wchar_t, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  UnitPrefix_member1::
  UnitPrefix_member1 (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, wchar_t, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  UnitPrefix_member1::
  UnitPrefix_member1 (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, wchar_t, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  UnitPrefix_member1::
  UnitPrefix_member1 (const ::std::wstring& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, wchar_t, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  UnitPrefix_member1* UnitPrefix_member1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UnitPrefix_member1 (*this, f, c);
  }

  UnitPrefix_member1::
  ~UnitPrefix_member1 ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace cellml12
{
  ::std::unique_ptr< ::cellml12::Model >
  parseModel (const ::std::wstring& u,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< wchar_t > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

    return ::std::unique_ptr< ::cellml12::Model > (
      ::cellml12::parseModel (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::cellml12::Model >
  parseModel (const ::std::wstring& u,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< wchar_t > ();

    return ::std::unique_ptr< ::cellml12::Model > (
      ::cellml12::parseModel (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::cellml12::Model >
  parseModel (const ::std::wstring& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< wchar_t > ();

    return ::std::unique_ptr< ::cellml12::Model > (
      ::cellml12::parseModel (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::cellml12::Model >
  parseModel (::std::istream& is,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::cellml12::parseModel (isrc, f, p);
  }

  ::std::unique_ptr< ::cellml12::Model >
  parseModel (::std::istream& is,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::cellml12::parseModel (isrc, h, f, p);
  }

  ::std::unique_ptr< ::cellml12::Model >
  parseModel (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::cellml12::parseModel (isrc, h, f, p);
  }

  ::std::unique_ptr< ::cellml12::Model >
  parseModel (::std::istream& is,
              const ::std::wstring& sid,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::cellml12::parseModel (isrc, f, p);
  }

  ::std::unique_ptr< ::cellml12::Model >
  parseModel (::std::istream& is,
              const ::std::wstring& sid,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::cellml12::parseModel (isrc, h, f, p);
  }

  ::std::unique_ptr< ::cellml12::Model >
  parseModel (::std::istream& is,
              const ::std::wstring& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::cellml12::parseModel (isrc, h, f, p);
  }

  ::std::unique_ptr< ::cellml12::Model >
  parseModel (::xercesc::InputSource& i,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< wchar_t > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

    return ::std::unique_ptr< ::cellml12::Model > (
      ::cellml12::parseModel (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::cellml12::Model >
  parseModel (::xercesc::InputSource& i,
              ::xml_schema::ErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< wchar_t > ();

    return ::std::unique_ptr< ::cellml12::Model > (
      ::cellml12::parseModel (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::cellml12::Model >
  parseModel (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< wchar_t > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< wchar_t > ();

    return ::std::unique_ptr< ::cellml12::Model > (
      ::cellml12::parseModel (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::cellml12::Model >
  parseModel (const ::xercesc::DOMDocument& doc,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::cellml12::Model > (
        ::cellml12::parseModel (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (e));

    if (n.name () == L"model" &&
        n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
    {
      ::std::unique_ptr< ::cellml12::Model > r (
        ::xsd::cxx::tree::traits< ::cellml12::Model, wchar_t >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
      n.name (),
      n.namespace_ (),
      L"model",
      L"http://www.cellml.org/cellml/1.2#");
  }

  ::std::unique_ptr< ::cellml12::Model >
  parseModel (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::Flags f,
              const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == L"model" &&
        n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
    {
      ::std::unique_ptr< ::cellml12::Model > r (
        ::xsd::cxx::tree::traits< ::cellml12::Model, wchar_t >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
      n.name (),
      n.namespace_ (),
      L"model",
      L"http://www.cellml.org/cellml/1.2#");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace cellml12
{
  void
  serializeModel (::std::ostream& o,
                  const ::cellml12::Model& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cellml12::serializeModel (s, m, f));

    ::xsd::cxx::tree::error_handler< wchar_t > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
    }
  }

  void
  serializeModel (::std::ostream& o,
                  const ::cellml12::Model& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cellml12::serializeModel (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< wchar_t > ();
    }
  }

  void
  serializeModel (::std::ostream& o,
                  const ::cellml12::Model& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cellml12::serializeModel (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< wchar_t > ();
    }
  }

  void
  serializeModel (::xercesc::XMLFormatTarget& t,
                  const ::cellml12::Model& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cellml12::serializeModel (s, m, f));

    ::xsd::cxx::tree::error_handler< wchar_t > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
    }
  }

  void
  serializeModel (::xercesc::XMLFormatTarget& t,
                  const ::cellml12::Model& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cellml12::serializeModel (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< wchar_t > ();
    }
  }

  void
  serializeModel (::xercesc::XMLFormatTarget& t,
                  const ::cellml12::Model& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cellml12::serializeModel (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< wchar_t > ();
    }
  }

  void
  serializeModel (::xercesc::DOMDocument& d,
                  const ::cellml12::Model& s,
                  ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< wchar_t > n (
      ::xsd::cxx::xml::dom::name< wchar_t > (e));

    if (n.name () == L"model" &&
        n.namespace_ () == L"http://www.cellml.org/cellml/1.2#")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"model",
        L"http://www.cellml.org/cellml/1.2#");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeModel (const ::cellml12::Model& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< wchar_t > (
        L"model",
        L"http://www.cellml.org/cellml/1.2#",
        m, f));

    ::cellml12::serializeModel (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const Model& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // import
    //
    for (Model::ImportConstIterator
         b (i.getImport ().begin ()), n (i.getImport ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"import",
          L"http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // units
    //
    for (Model::UnitsConstIterator
         b (i.getUnits ().begin ()), n (i.getUnits ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"units",
          L"http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // component
    //
    for (Model::ComponentConstIterator
         b (i.getComponent ().begin ()), n (i.getComponent ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"component",
          L"http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // encapsulation
    //
    for (Model::EncapsulationConstIterator
         b (i.getEncapsulation ().begin ()), n (i.getEncapsulation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"encapsulation",
          L"http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // connection
    //
    for (Model::ConnectionConstIterator
         b (i.getConnection ().begin ()), n (i.getConnection ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"connection",
          L"http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"name",
          e));

      a << i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Import& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // units
    //
    for (Import::UnitsConstIterator
         b (i.getUnits ().begin ()), n (i.getUnits ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"units",
          L"http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // component
    //
    for (Import::ComponentConstIterator
         b (i.getComponent ().begin ()), n (i.getComponent ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"component",
          L"http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // href
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"href",
          e));

      a << i.getHref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Units& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // unit
    //
    for (Units::UnitConstIterator
         b (i.getUnit ().begin ()), n (i.getUnit ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"unit",
          L"http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"name",
          e));

      a << i.getName ();
    }

    // base_units
    //
    if (i.getBase_units ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"base_units",
          e));

      a << *i.getBase_units ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Unit& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // units
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"units",
          e));

      a << i.getUnits ();
    }

    // multiplier
    //
    if (i.getMultiplier ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"multiplier",
          e));

      a << ::xml_schema::AsDouble(*i.getMultiplier ());
    }

    // prefix
    //
    if (i.getPrefix ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"prefix",
          e));

      a << *i.getPrefix ();
    }

    // offset
    //
    if (i.getOffset ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"offset",
          e));

      a << ::xml_schema::AsDouble(*i.getOffset ());
    }

    // exponent
    //
    if (i.getExponent ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"exponent",
          e));

      a << ::xml_schema::AsDouble(*i.getExponent ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Component& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // units
    //
    for (Component::UnitsConstIterator
         b (i.getUnits ().begin ()), n (i.getUnits ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"units",
          L"http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // variable
    //
    for (Component::VariableConstIterator
         b (i.getVariable ().begin ()), n (i.getVariable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"variable",
          L"http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // math
    //
    for (Component::MathConstIterator
         b (i.getMath ().begin ()), n (i.getMath ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"math",
          L"http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"name",
          e));

      a << i.getName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Encapsulation& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // component_ref
    //
    for (Encapsulation::Component_refConstIterator
         b (i.getComponent_ref ().begin ()), n (i.getComponent_ref ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"component_ref",
          L"http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ToplevelComponentRef& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // component_ref
    //
    for (ToplevelComponentRef::Component_refConstIterator
         b (i.getComponent_ref ().begin ()), n (i.getComponent_ref ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"component_ref",
          L"http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // component
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"component",
          e));

      a << i.getComponent ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ComponentRef& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // component_ref
    //
    for (ComponentRef::Component_refConstIterator
         b (i.getComponent_ref ().begin ()), n (i.getComponent_ref ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"component_ref",
          L"http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // component
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"component",
          e));

      a << i.getComponent ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Connection& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // map_variables
    //
    for (Connection::Map_variablesConstIterator
         b (i.getMap_variables ().begin ()), n (i.getMap_variables ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          L"map_variables",
          L"http://www.cellml.org/cellml/1.2#",
          e));

      s << *b;
    }

    // component_1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"component_1",
          e));

      a << i.getComponent_1 ();
    }

    // component_2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"component_2",
          e));

      a << i.getComponent_2 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ImportedUnits& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"name",
          e));

      a << i.getName ();
    }

    // units_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"units_ref",
          e));

      a << i.getUnits_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ImportedComponent& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"name",
          e));

      a << i.getName ();
    }

    // component_ref
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"component_ref",
          e));

      a << i.getComponent_ref ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Variable& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"name",
          e));

      a << i.getName ();
    }

    // units
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"units",
          e));

      a << i.getUnits ();
    }

    // public_interface
    //
    if (i.getPublic_interface ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"public_interface",
          e));

      a << *i.getPublic_interface ();
    }

    // private_interface
    //
    if (i.getPrivate_interface ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"private_interface",
          e));

      a << *i.getPrivate_interface ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"type",
          e));

      a << i.getType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MapVariables& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // variable_1
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"variable_1",
          e));

      a << i.getVariable_1 ();
    }

    // variable_2
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          L"variable_2",
          e));

      a << i.getVariable_2 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CellMLIdentifier& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CellMLIdentifier& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CellMLIdentifier& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const UnitPrefix& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const UnitPrefix& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const UnitPrefix& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Yesno& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Yesno& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Yesno& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const UnitPrefix_member& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const UnitPrefix_member& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const UnitPrefix_member& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const UnitPrefix_member1& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, wchar_t, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const UnitPrefix_member1& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, wchar_t, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const UnitPrefix_member1& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, wchar_t, ::xml_schema::SimpleType >& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

